# Testing

## Notes

## Setting Up Testing Environment
- We use Vitest as our testing framework, which is a Vite-native test runner. happy-dom is used as the testing environment.
```bash
pnpm install -D vitest @testing-library/react happy-dom
```
- we configured test environment in `vite.config.js`:
```js
...
  test: {
    environment: 'happy-dom',
  }
...
``` 
## Writing Tests on Pizza Component
- We create a test file `src/__tests__/Pizza.test.jsx` to test the `Pizza` component.
- as long as it's on the `__tests__` folder or has `.test.jsx` suffix, Vitest will automatically pick it up as a test file.
```jsx
test("alt text renders on image", async () => {
  const name = "My Favorite Pizza";
  const src = "https://picsum.photos/200";
  const screen = render(
    <Pizza name={name} description="super cool pizza" image={src} />
  );

  const img = screen.getByRole("img");
  expect(img.src).toBe(src);
  expect(img.alt).toBe(name);
}); 
```
## Clean Up After Each Test
- We use `afterEach(cleanup);` to ensure that the DOM is cleaned up after each test, preventing tests from affecting each other.
```jsx
import { render, cleanup } from "@testing-library/react";
import { afterEach } from "vitest";

afterEach(cleanup);
```
- Either we can call `cleanup` manually after each test or use `afterEach(cleanup);` to automate it.

## Additional Test for Default Image on Pizza Component
- We added another test to check if the `Pizza` component uses a default image when no image prop is provided.
```jsx
test("to have default image if none is provided", async () => {
  const screen = render(
    <Pizza name={"Cool Pizza"} description="super cool pizza" />
  );

  const img = screen.getByRole("img");
  expect(img.src).not.toBe("");
});
```
- we should also update the `Pizza` component to handle the case where no image prop is provided:
```jsx
 <img src={props.image ? props.image : "https://picsum.photos/200"} alt={props.name} />
```
- Everything should work from now

## Mocking (Testing contact page)
- First we need a helper function `vitest-fetch-mock` to mock the fetch API in our tests.
```bash
pnpm install -D vitest-fetch-mock
```
- In our test file `src/__tests__/contact.lazy.node.test.jsx`, we set up the fetch mocker:
```jsx
const queryClient = new QueryClient();

const fetchMocker = createFetchMock(vi);
fetchMocker.enableMocks();

test("can submit contact form", async () => {
  fetchMocker.mockResponse(JSON.stringify({ status: "ok" }));
  const screen = render(
    <QueryClientProvider client={queryClient}>
      <Route.options.component />
    </QueryClientProvider>
  );

  const nameInput = screen.getByPlaceholderText("Name");
  const emailInput = screen.getByPlaceholderText("Email");
  const msgTextArea = screen.getByPlaceholderText("Message");

  const testData = {
    name: "Brian",
    email: "test@example.com",
    message: "This is a test message",
  };

  nameInput.value = testData.name;
  emailInput.value = testData.email;
  msgTextArea.value = testData.message;

  const btn = screen.getByRole("button");

  btn.click();

  const h3 = await screen.findByRole("heading", { level: 3 });

  expect(h3.innerText).toContain("Submitted");

  const requests = fetchMocker.requests();
  expect(requests.length).toBe(1);
  expect(requests[0].url).toBe("http://localhost:3000/api/contact");
  expect(fetchMocker).toHaveBeenCalledWith("/api/contact", {
    body: JSON.stringify(testData),
    headers: {
      "Content-Type": "application/json",
    },
    method: "POST",
  });
});
```
- The `vi` is Vitest's spy library. 
- `vitest-fetch-mock` is just a nice layer on top of vi. We could just use `vi.spyOn(global, 'fetch')` directly if we wanted to.

## Custom Hook Testing (usePizzaOfTheDay)
- First we test the hook with a fake component before using `renderHook` from `@testing-library/react`.
```jsx
function getPizzaOfTheDay() {
  let pizza;

  function TestComponent() {
    pizza = usePizzaOfTheDay();
    return null;
  }

  render(<TestComponent />);

  return pizza;
}

test("gives null when first called", async () => {
  fetch.mockResponseOnce(JSON.stringify(testPizza));
  const pizza = getPizzaOfTheDay();
  expect(pizza).toBeNull();
});
```
- Then instead of writing a fake component, we can use `renderHook` to test the hook directly.
```jsx
test("to be null on initial load", async () => {
  fetch.mockResponseOnce(JSON.stringify(testPizza));
  const { result } = renderHook(() => usePizzaOfTheDay(""));
  expect(result.current).toBeNull();
});
```
- In addition, we add another test to check the API calls instead of just null cheking.
```jsx
test("to call the API and give back the pizza of the day", async () => {
  fetch.mockResponseOnce(JSON.stringify(testPizza));
  const { result } = renderHook(() => usePizzaOfTheDay(""));
  await waitFor(() => {
    expect(result.current).toEqual(testPizza);
  });
  expect(fetchMocker).toBeCalledWith("/api/pizza-of-the-day");
});
```
- As we can see, we use `waitFor` to wait for the asynchronous update of the hook's state before making assertions. So the test will wait until the pizza data is fetched and the state is updated before checking the result.

## Snapshot Testing
- Vitest creates snapshot files automatically when we run tests with snapshot assertions for the first time.
- We can see it's just rendering out what it would look like on `__snapshots__` folder.
- Some people don't find it useful. Just in case, some times they can be helpful.
- Here is an example of snapshot testing for a `Cart` component when the cart is empty:
```jsx
test("snapshot with nothing in cart", () => {
  const { asFragment } = render(<Cart cart={[]} />);
  expect(asFragment()).toMatchSnapshot();
});
```
- And another example when the cart has items:
```jsx

test("snapshot with some stuff in cart", () => {
  const { asFragment } = render(
    <Cart
      cart={[
        {
          pizza: {
            id: "pepperoni",
            name: "The Pepperoni Pizza",
            category: "Classic",
            description: "Mozzarella Cheese, Pepperoni",
            image: "/public/pizzas/pepperoni.webp",
            sizes: {
              S: 9.75,
              M: 12.5,
              L: 15.25,
            },
          },
          size: "M",
          price: "$12.50",
        },
        {
          pizza: {
            id: "ckn_pesto",
            name: "The Chicken Pesto Pizza",
            category: "Chicken",
            description:
              "Chicken, Tomatoes, Red Peppers, Spinach, Garlic, Pesto Sauce",
            image: "/public/pizzas/ckn_pesto.webp",
            sizes: {
              S: 12.75,
              M: 16.75,
              L: 20.75,
            },
          },
          size: "L",
          price: "$20.75",
        },
        {
          pizza: {
            id: "bbq_ckn",
            name: "The Barbecue Chicken Pizza",
            category: "Chicken",
            description:
              "Barbecued Chicken, Red Peppers, Green Peppers, Tomatoes, Red Onions, Barbecue Sauce",
            image: "/public/pizzas/bbq_ckn.webp",
            sizes: {
              S: 12.75,
              M: 16.75,
              L: 20.75,
            },
          },
          size: "S",
          price: "$12.75",
        },
      ]}
    />
  );
  expect(asFragment()).toMatchSnapshot();
});
```
- If we look at the snapshot, it's rendering Pizza components as well. Now if we modify `Pizza.jsx` (that has its own tests already) your `Cart.jsx` test is going to fail. This is misleading, nothing is wrong or different with `Cart.jsx`. 
- Update the snapshot by either running `npm run test -- -u` or you can use the watcher to do it with either `u` to update all at once or `i` one-by-one.
- We should commit this snapshot to the git.