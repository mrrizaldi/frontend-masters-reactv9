# Testing

## Notes

## Setting Up Testing Environment
- We use Vitest as our testing framework, which is a Vite-native test runner. happy-dom is used as the testing environment.
```bash
pnpm install -D vitest @testing-library/react happy-dom
```
- we configured test environment in `vite.config.js`:
```js
...
  test: {
    environment: 'happy-dom',
  }
...
``` 
## Writing Tests on Pizza Component
- We create a test file `src/__tests__/Pizza.test.jsx` to test the `Pizza` component.
- as long as it's on the `__tests__` folder or has `.test.jsx` suffix, Vitest will automatically pick it up as a test file.
```jsx
test("alt text renders on image", async () => {
  const name = "My Favorite Pizza";
  const src = "https://picsum.photos/200";
  const screen = render(
    <Pizza name={name} description="super cool pizza" image={src} />
  );

  const img = screen.getByRole("img");
  expect(img.src).toBe(src);
  expect(img.alt).toBe(name);
}); 
```
## Clean Up After Each Test
- We use `afterEach(cleanup);` to ensure that the DOM is cleaned up after each test, preventing tests from affecting each other.
```jsx
import { render, cleanup } from "@testing-library/react";
import { afterEach } from "vitest";

afterEach(cleanup);
```
- Either we can call `cleanup` manually after each test or use `afterEach(cleanup);` to automate it.

## Additional Test for Default Image on Pizza Component
- We added another test to check if the `Pizza` component uses a default image when no image prop is provided.
```jsx
test("to have default image if none is provided", async () => {
  const screen = render(
    <Pizza name={"Cool Pizza"} description="super cool pizza" />
  );

  const img = screen.getByRole("img");
  expect(img.src).not.toBe("");
});
```
- we should also update the `Pizza` component to handle the case where no image prop is provided:
```jsx
 <img src={props.image ? props.image : "https://picsum.photos/200"} alt={props.name} />
```
- Everything should work from now

## Mocking (Testing contact page)
- First we need a helper function `vitest-fetch-mock` to mock the fetch API in our tests.
```bash
pnpm install -D vitest-fetch-mock
```
- In our test file `src/__tests__/contact.lazy.node.test.jsx`, we set up the fetch mocker:
```jsx
const queryClient = new QueryClient();

const fetchMocker = createFetchMock(vi);
fetchMocker.enableMocks();

test("can submit contact form", async () => {
  fetchMocker.mockResponse(JSON.stringify({ status: "ok" }));
  const screen = render(
    <QueryClientProvider client={queryClient}>
      <Route.options.component />
    </QueryClientProvider>
  );

  const nameInput = screen.getByPlaceholderText("Name");
  const emailInput = screen.getByPlaceholderText("Email");
  const msgTextArea = screen.getByPlaceholderText("Message");

  const testData = {
    name: "Brian",
    email: "test@example.com",
    message: "This is a test message",
  };

  nameInput.value = testData.name;
  emailInput.value = testData.email;
  msgTextArea.value = testData.message;

  const btn = screen.getByRole("button");

  btn.click();

  const h3 = await screen.findByRole("heading", { level: 3 });

  expect(h3.innerText).toContain("Submitted");

  const requests = fetchMocker.requests();
  expect(requests.length).toBe(1);
  expect(requests[0].url).toBe("http://localhost:3000/api/contact");
  expect(fetchMocker).toHaveBeenCalledWith("/api/contact", {
    body: JSON.stringify(testData),
    headers: {
      "Content-Type": "application/json",
    },
    method: "POST",
  });
});
```
- The `vi` is Vitest's spy library. 
- `vitest-fetch-mock` is just a nice layer on top of vi. We could just use `vi.spyOn(global, 'fetch')` directly if we wanted to.