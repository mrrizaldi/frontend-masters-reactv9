# Advanced React

## Notes

## Portals
- Portals provide a first-class way to render children into a DOM node that exists outside the DOM hierarchy of the parent component.
- This is useful for UI components like modals, tooltips, or hovercards that need to visually "break out" of their container (e.g. to avoid `overflow: hidden` or `z-index` issues).
- We use `createPortal` from `react-dom`.

### useRef
- `useRef` is a hook that returns a mutable ref object whose `.current` property is initialized to the passed argument.
- The returned object persists for the full lifetime of the component.
- It is commonly used to access a child imperatively (like a DOM node) or to keep a mutable variable that doesn't trigger a re-render when changed.

### Modal Implementation
- In `src/Modal.jsx`, we combine `useRef` and `createPortal` to create a reusable Modal component.
- **Singleton-like Container**: We use `useRef` to create a `div` element *once* and store it. This ensures the container `div` remains the same instance across re-renders of the Modal component.
```jsx
  const elRef = useRef(null);
  if (!elRef.current) {
    elRef.current = document.createElement("div");
  }
```
- **Mounting/Unmounting**: We use `useEffect` to append this `div` to the DOM (specifically to the `#modal` root) when the Modal mounts, and remove it when it unmounts.
```jsx
  useEffect(() => {
    const modalRoot = document.getElementById("modal");
    modalRoot.appendChild(elRef.current);
    return () => modalRoot.removeChild(elRef.current);
  }, []);
```
- **Rendering**: Finally, we use `createPortal` to render the `children` into that specific `div`.
```jsx
  return createPortal(<div>{children}</div>, elRef.current);
```

### Usage in Past Orders
- In `src/routes/past.lazy.jsx`, we use the `Modal` to display order details.
- Because the `Modal` uses `useRef` for its container, when the content inside the modal changes (e.g., from a "Loading..." state to displaying the table of items), the modal container itself does not get destroyed and recreated.
- This prevents flickering and loss of focus, providing a smoother user experience during state transitions inside the modal.

## Error Boundaries
- Error Boundaries are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of the component tree that crashed.
- They are like a JavaScript `try/catch` block, but for components.
- **Important**: Error boundaries do not catch errors for:
  - Event handlers
  - Asynchronous code (e.g. `setTimeout` or `requestAnimationFrame` callbacks)
  - Server side rendering
  - Errors thrown in the error boundary itself (rather than its children)

### Class Components
- Before React Hooks (v16.8), Class Components were the only way to have state and lifecycle methods in React.
- While Function Components + Hooks are now the standard, Error Boundaries **must** still be written as Class Components because there are no Hook equivalents for `getDerivedStateFromError` and `componentDidCatch` yet.
- Key differences from Function Components:
  - Must extend `Component` from React.
  - Must have a `render()` method.
  - State is an object accessed via `this.state`.
  - Props are accessed via `this.props`.

### Implementation
- In `src/ErrorBoundary.jsx`, we created a class component to handle errors:
```jsx
class ErrorBoundary extends Component {
  state = { hasError: false };
  
  // Update state so the next render will show the fallback UI.
  static getDerivedStateFromError() {
    return { hasError: true };
  }
  
  // We can also log the error to an error reporting service
  componentDidCatch(error, info) {
    console.error("ErrorBoundary caught an error", error, info);
  }
  
  render() {
    if (this.state.hasError) {
      return <h2>Uh oh! There was an error.</h2>;
    }
    return this.props.children;
  }
}
```

### Usage in Past Orders
- We wrapped the `PastOrdersRoute` component with our `ErrorBoundary` in `src/routes/past.lazy.jsx`.
- This ensures that if the API call fails or rendering the table crashes, the user sees a nice error message instead of a blank screen, and the rest of the app (like the header) remains functional.
```jsx
function ErrorBoundaryWrappedPastOrderRoutes() {
  return (
    <ErrorBoundary>
      <PastOrdersRoute />
    </ErrorBoundary>
  );
}
```

## Uncontrolled Forms
- **Uncontrolled Forms** are forms where the form data is handled by the DOM itself, rather than by the React component's state.
- Instead of writing an `onChange` handler for every input and updating a state variable (Controlled Component), we wait until the form is submitted and then read the values directly from the DOM element.
- This is often simpler for basic forms (like a contact form) where you don't need instant validation as the user types.

### FormData API
- We use the browser's native `FormData` API to easily extract values from the form when it is submitted.
```jsx
    mutationFn: function (e) {
      e.preventDefault();
      const formData = new FormData(e.target);
      return postContact(
        formData.get("name"),
        formData.get("email"),
        formData.get("message")
      );
    },
```

### TanStack Query Mutations
- While `useQuery` is for fetching data (GET), `useMutation` is for creating/updating/deleting data (POST, PUT, DELETE).
- In `src/routes/contact.lazy.jsx`, we use `useMutation` to handle the form submission.
- **`mutation.mutate`**: This function is passed to the form's `onSubmit`. It triggers the `mutationFn`.
- **`mutation.isSuccess`**: A boolean that tells us if the mutation completed successfully. We use this to conditionally render a "Submitted!" message instead of the form.
```jsx
  const mutation = useMutation({
    mutationFn: function (e) {
      // ... handle submit
    }
  });

  // ... inside render
  {mutation.isSuccess ? (
    <h3>Submitted!</h3>
  ) : (
    <form onSubmit={mutation.mutate}>
      {/* inputs */}
    </form>
  )}
```